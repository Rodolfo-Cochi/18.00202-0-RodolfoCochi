%% Exponencial Positivaclear all;clc;close all;pkg load symbolic;%% Definindo o filtro e ser utilizado%% Criando o filtro passa baixas - FPBHFPB = @(w,wc)     wc./(j*w+wc)wc = 2*pi;                % frequência de corte%% Definindo o sinal a ser estudado%% Ona pulsada de dois níveis, período To e largura tau A1 = 1;                  % Amplitude em nível alto A2 = 0;                  % Amplitude em nível baixo tau = 0.5;               % Duração em nível alto To = 1;                  % Período %%% Valores calculados fo = inv(To);            % frequência em Hz wo = 2*pi*fo;            % frequência angular N = 10;                 % Número de harmônicas da análise n=[-N:1:N];              % índice de cada harmônica f = n*fo;                % vetor de frequências da análise de Fourier%%% Vetor tempo para visualização do sinal%%% diferente da variável simbólica t%%% para efeito de organização da solução%%% existem outros caminhos M = 1000; Ts = To/M; tempo = [0:Ts:To];            % Tempo de simulação de um período do sinal g(t)  %% Determinando o termo Dn simbolicamentesyms n tDn = inv(To)*int(A1*exp(-j*n*wo*t),t,0,tau) + inv(To)*int(A2*exp(-j*n*wo*t),t,tau,To);D_o = inv(To)*int(A1,t,0,tau) + inv(To)*int(A2,t,tau,To);%% Determinando o termo Dn numericamenten=[-N:1:N]; Dn = eval(Dn)D_o = eval(D_o)      % Corrigindo o valor médio (NaN devido a indeterminação)Dn(N+1) = D_o        % Subistituindo no vetor de respostas%% Visualizando o espector de Amplitude figure(1) stem(f,abs(Dn)); title('Série de Fourier do sinal g(t)');xlabel('Frequência em Hz');ylabel('Amplitude em  volts')%% Sintetizando o sinaln=[-N:1:N];aux  = 0;             for k = 0 : 2*N          aux = aux + Dn(k+1)*exp(j*n(k+1)*wo*tempo);  endgr = aux;%% Visualizando o sinal reconstruidofigure(2)plot(tempo,gr)title('Reconstrução do sinal g(t)');xlabel('Tempo em segundos');ylabel('Amplitude em  volts')%% Determinando a potência do sinal g(t)Pg = inv(To)*int(A1^2,t,0,tau) + inv(To)*int(A2^2,t,tau,To)Pg = eval(Pg)%%% Verifica a potência pelo teorema de PaservalPN = cumsum([Dn(N+1)^2 2*abs(Dn(N+2:end)).^2])figure(3)plot(f(N+1:end),PN,f(N+1:end),ones(1,N+1)*Pg)title('Potência total e em função do harmônico');xlabel('Harmônico');ylabel('Potência em W')%% Testando o filtrou  = sin(2*pi*tempo);       % Sinal de entrada com frequência f=1HzGw = HFPB(2*pi,wc);         % Ganho do filtroy  = abs(Gw)*sin(2*pi*tempo+angle(Gw)); % saída do filtro modificando amplitude e fasefigure(4)plot(tempo,u,tempo,y)title('Entrada e saída do filtro passa baixas')xlabel('tempo me sgeundos')ylabel('Amplitude em volts')%% Aplicando a onda quadrada na entrada do filtroGq = HFPB(2*pi*f,wc);         % determina o ganho do filtro na faixa na onda pulsadafigure(5)subplot(1,2,1);plot(2*pi*f,abs(Gq)); title('Resposta em frequência')xlabel('Frequência angular')ylabel('Ganho')subplot(1,2,2);plot(2*pi*f,angle(Gq)*180/pi); title('Resposta em frequência')xlabel('Frequência angular')ylabel('fase')%% Sintetizando o sinal de saída%% Para cada harmônico da entrada aplicamos o ganho HFPB%% Multiplicando pelo termo HFPB(2*pi*f(k+1),wc)n=[-N:1:N];aux  = 0;             for k = 0 : 2*N          aux = aux + HFPB(2*pi*f(k+1),wc)*Dn(k+1)*exp(j*n(k+1)*wo*tempo);  endy = aux;%% Visualizando o sinal reconstruidofigure(6)plot(tempo,gr,tempo,y)title('Reconstrução do sinal de entrada e de saída');xlabel('Tempo em segundos');ylabel('Amplitude em  volts')  